/*
子父类中的构造函数的特点

在子类构造对象时，发现，访问子类构造函数时，父类也运行了。
为什么？

原因是：在子类中的构造函数中第一行有一个默认的隐式语句，super();

子类的实例化过程：子类中所有的构造函数都会访问父类中的空参数的构造函数。


为什么子类实例化时要访问父类中的空参数构造函数？

*/


class Fu
{

	int num;
	Fu()
	{
		num=10;
		System.out.println("A Hello  Fu!");
	}
	Fu(int x)
	{
		System.out.println("B Hello  Fu!"+x);
	}

}
class Zi extends Fu
{
	Zi()
	{

		//super();//调用的就是父类中的空参数的构造函数。

		System.out.println("C Hello  Zi!"+num);
	}

	Zi(int x)
	{
		//super();
		System.out.println("D Hello  Zi!"+x);
	}

}

class ExtendsDemo4 
{
	public static void main(String[] args) 
	{
	new Zi(6);
	
	//	System.out.println("Hello World!");
	}
}
